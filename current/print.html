<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js lfe-pdp">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>LFE MACHINE MANUAL</title>
    
    <meta name="robots" content="noindex" />
    
    


    <!-- Custom HTML head -->
    


    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="The Manual for the Machine that is LFE/OTP">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    
    <link rel="stylesheet" href="fonts/fonts.css">
    

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
    <link rel="stylesheet" href="css/custom.css">
    

    
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "lfe-pdp" : "lfe-pdp";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('lfe-pdp')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item affix "><a href="index.html">LFE MACHINE MANUAL</a></li><li class="chapter-item affix "><a href="fm/title-page.html">Title Page</a></li><li class="chapter-item affix "><a href="fm/copyright.html">Copyright</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="preface/index.html">Preface</a></li><li class="chapter-item affix "><a href="preface/about-cover.html">About the Cover</a></li><li class="chapter-item affix "><a href="preface/dedication.html">Dedication</a></li><li class="chapter-item affix "><a href="preface/forward.html">Forward</a></li><li class="chapter-item affix "><a href="preface/acknowledgments.html">Acknowledgments</a></li><li class="spacer"></li><li class="chapter-item "><a href="part1/index.html"><strong aria-hidden="true">1.</strong> Part I - Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/index.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item "><a href="part1/intro/prereq.html"><strong aria-hidden="true">1.2.</strong> Prerequisites</a></li><li class="chapter-item "><a href="part1/intro/conventions.html"><strong aria-hidden="true">1.3.</strong> Conventions</a></li><li class="chapter-item "><a href="part1/intro/setup.html"><strong aria-hidden="true">1.4.</strong> Development Setup</a></li><li class="chapter-item "><a href="part1/intro/hw/index.html"><strong aria-hidden="true">1.5.</strong> 'Hello, World!'</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/hw/repl.html"><strong aria-hidden="true">1.5.1.</strong> Classic, REPL</a></li><li class="chapter-item "><a href="part1/intro/hw/main.html"><strong aria-hidden="true">1.5.2.</strong> Classic, main</a></li><li class="chapter-item "><a href="part1/intro/hw/otp.html"><strong aria-hidden="true">1.5.3.</strong> LFE/OTP</a></li></ol></li><li class="chapter-item "><a href="part1/intro/guessing-game/index.html"><strong aria-hidden="true">1.6.</strong> Walk-through: An LFE Guessing Game</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/guessing-game/planning.html"><strong aria-hidden="true">1.6.1.</strong> Planning the Game</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/code.html"><strong aria-hidden="true">1.6.2.</strong> Code Explore</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/guessing-game/input.html"><strong aria-hidden="true">1.6.2.1.</strong> Getting User Input</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/check.html"><strong aria-hidden="true">1.6.2.2.</strong> Checking the Input</a></li></ol></li><li class="chapter-item "><a href="part1/intro/guessing-game/integrate.html"><strong aria-hidden="true">1.6.3.</strong> Integrating into an Application</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/intro/guessing-game/cast.html"><strong aria-hidden="true">1.6.3.1.</strong> handle_cast</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/api.html"><strong aria-hidden="true">1.6.3.2.</strong> Game API</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/finishing-touches.html"><strong aria-hidden="true">1.6.3.3.</strong> Finishing Touches</a></li><li class="chapter-item "><a href="part1/intro/guessing-game/play.html"><strong aria-hidden="true">1.6.3.4.</strong> Playing the Game</a></li></ol></li><li class="chapter-item "><a href="part1/intro/guessing-game/review.html"><strong aria-hidden="true">1.6.4.</strong> Code Review</a></li></ol></li><li class="chapter-item "><a href="part1/repl/index.html"><strong aria-hidden="true">1.7.</strong> The LFE REPL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/repl/features.html"><strong aria-hidden="true">1.7.1.</strong> Core Features</a></li><li class="chapter-item "><a href="part1/repl/start.html"><strong aria-hidden="true">1.7.2.</strong> Starting LFE</a></li><li class="chapter-item "><a href="part1/repl/readline.html"><strong aria-hidden="true">1.7.3.</strong> readline Support</a></li><li class="chapter-item "><a href="part1/repl/help.html"><strong aria-hidden="true">1.7.4.</strong> (help)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/repl/help-builtins.html"><strong aria-hidden="true">1.7.4.1.</strong> REPL Functions</a></li><li class="chapter-item "><a href="part1/repl/help-cmds.html"><strong aria-hidden="true">1.7.4.2.</strong> REPL Commands</a></li><li class="chapter-item "><a href="part1/repl/help-special-vars.html"><strong aria-hidden="true">1.7.4.3.</strong> Special Variables</a></li></ol></li><li class="chapter-item "><a href="part1/repl/c.html"><strong aria-hidden="true">1.7.5.</strong> Command Interface</a></li><li class="chapter-item "><a href="part1/repl/job-control.html"><strong aria-hidden="true">1.7.6.</strong> Job Control</a></li></ol></li></ol></li><li class="chapter-item "><strong aria-hidden="true">2.</strong> Part II - Code as Data<a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part2/data-types/index.html"><strong aria-hidden="true">2.1.</strong> Primitive Types</a></li><li class="chapter-item "><a href="part2/data-types/index.html"><strong aria-hidden="true">2.2.</strong> Conss</a></li><li class="chapter-item "><a href="part2/lists/index.html"><strong aria-hidden="true">2.3.</strong> Lists and Strings</a></li><li class="chapter-item "><a href="part2/byte-bin/index.html"><strong aria-hidden="true">2.4.</strong> Bytes and Binaries</a></li><li class="chapter-item "><a href="part2/tuples/index.html"><strong aria-hidden="true">2.5.</strong> Tuples</a></li><li class="chapter-item "><a href="part2/proplists/index.html"><strong aria-hidden="true">2.6.</strong> Property Lists</a></li><li class="chapter-item "><a href="part2/maps/index.html"><strong aria-hidden="true">2.7.</strong> Maps</a></li><li class="chapter-item "><a href="part2/patterns/index.html"><strong aria-hidden="true">2.8.</strong> Pattern Matching</a></li><li class="chapter-item "><a href="part2/arrays/index.html"><strong aria-hidden="true">2.9.</strong> Arrays</a></li><li class="chapter-item "><a href="part2/dicts/index.html"><strong aria-hidden="true">2.10.</strong> Dicts</a></li><li class="chapter-item "><a href="part2/records/index.html"><strong aria-hidden="true">2.11.</strong> Records</a></li><li class="chapter-item "><a href="part2/gen-seq/index.html"><strong aria-hidden="true">2.12.</strong> Generic Sequence Functions</a></li></ol></li><li class="chapter-item "><strong aria-hidden="true">3.</strong> Part III - Data as Code<a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part3/exprs/index.html"><strong aria-hidden="true">3.1.</strong> Expressions</a></li><li class="chapter-item "><a href="part3/funs/index.html"><strong aria-hidden="true">3.2.</strong> Functions</a></li><li class="chapter-item "><a href="part3/closures/index.html"><strong aria-hidden="true">3.3.</strong> Closures</a></li><li class="chapter-item "><a href="part3/eval/index.html"><strong aria-hidden="true">3.4.</strong> Evaluation</a></li><li class="chapter-item "><a href="part3/expressioins/index.html"><strong aria-hidden="true">3.5.</strong> Expressions</a></li><li class="chapter-item "><a href="part3/processes/index.html"><strong aria-hidden="true">3.6.</strong> Processes</a></li><li class="chapter-item "><a href="part3/msgs/index.html"><strong aria-hidden="true">3.7.</strong> Messages and Their Passing</a></li><li class="chapter-item "><a href="part3/objects/index.html"><strong aria-hidden="true">3.8.</strong> Objects and Flavors</a></li><li class="chapter-item "><a href="part3/io/index.html"><strong aria-hidden="true">3.9.</strong> I/O</a></li><li class="chapter-item "><a href="part3/files/index.html"><strong aria-hidden="true">3.10.</strong> Accessing Files</a></li><li class="chapter-item "><a href="part3/modules/index.html"><strong aria-hidden="true">3.11.</strong> Modules</a></li><li class="chapter-item "><a href="part3/packages/index.html"><strong aria-hidden="true">3.12.</strong> Packages</a></li><li class="chapter-item "><a href="part3/scripting/index.html"><strong aria-hidden="true">3.13.</strong> Scripting with LFE</a></li></ol></li><li class="chapter-item "><strong aria-hidden="true">4.</strong> Part IV - Advanced Topics<a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part4/err-debug/index.html"><strong aria-hidden="true">4.1.</strong> Errors and Debugging</a></li><li class="chapter-item "><a href="part4/unit/index.html"><strong aria-hidden="true">4.2.</strong> Writing Unit Tests</a></li><li class="chapter-item "><a href="part4/ct/index.html"><strong aria-hidden="true">4.3.</strong> The Common Test Framework</a></li><li class="chapter-item "><a href="part4/propr/index.html"><strong aria-hidden="true">4.4.</strong> The Propr Test Framework</a></li><li class="chapter-item "><a href="part4/compiler/index.html"><strong aria-hidden="true">4.5.</strong> The Compiler</a></li><li class="chapter-item "><a href="part4/macros/index.html"><strong aria-hidden="true">4.6.</strong> Macros</a></li><li class="chapter-item "><a href="part4/dist/index.html"><strong aria-hidden="true">4.7.</strong> Distributed LFE</a></li><li class="chapter-item "><a href="part4/ports/REAEDME.html"><strong aria-hidden="true">4.8.</strong> Ports and Port Drivers</a></li><li class="chapter-item "><a href="part4/servers/REAEDME.html"><strong aria-hidden="true">4.9.</strong> Servers</a></li><li class="chapter-item "><a href="part4/clients/REAEDME.html"><strong aria-hidden="true">4.10.</strong> Clients</a></li></ol></li><li class="chapter-item "><strong aria-hidden="true">5.</strong> Part V - OTP<a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part5/behaviours/index.html"><strong aria-hidden="true">5.1.</strong> Behaviours</a></li><li class="chapter-item "><a href="part5/apps/index.html"><strong aria-hidden="true">5.2.</strong> Applications</a></li><li class="chapter-item "><a href="part5/rels/index.html"><strong aria-hidden="true">5.3.</strong> Releases</a></li><li class="chapter-item "><a href="part5/data/index.html"><strong aria-hidden="true">5.4.</strong> Tables and Databases</a></li><li class="chapter-item "><a href="part5/project/index.html"><strong aria-hidden="true">5.5.</strong> Example OTP Project</a></li></ol></li><li class="chapter-item "><strong aria-hidden="true">6.</strong> Part VI - Conclusion<a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part6/epilogue.html"><strong aria-hidden="true">6.1.</strong> Epilogue</a></li><li class="chapter-item "><a href="part6/afterward.html"><strong aria-hidden="true">6.2.</strong> Afterword</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><a href="epilogue/glossary.html">Glossary</a></li><li class="chapter-item affix "><a href="epilogue/bibliography.html">Bibliography</a></li><li class="chapter-item affix "><a href="epilogue/index.html">Index</a></li><li class="spacer"></li><li class="chapter-item affix ">Appendices</li><li class="chapter-item affix "><a href="appendices/lisp-history.html">I - Origins Of Lisp</a></li><li class="chapter-item affix "><a href="appendices/erlang-history.html">II - Origins Of Erlang</a></li><li class="chapter-item affix "><a href="appendices/lfe-overview.html">III - Origins Of LFE</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="versions.html">Versions</a></li><li class="chapter-item affix "><a href="feedback.html">Feedback</a></li><li class="chapter-item affix "><a href="redirects/docs.html">LFE Documentation</a></li><li class="chapter-item affix "><a href="redirects/mdbook.html">Built with mdBook</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme"
                                id="lfe-pdp">LFE PDP</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="light">Light</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme"
                                id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    
                </div>

                <h1 class="menu-title">LFE MACHINE MANUAL</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    
                    <a href="https://github.com/cnbbooks/lfe-manual" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    
                </div>
            </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                        placeholder="Search this book ..." aria-controls="searchresults-outer"
                        aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <p><a href="images/cover-large.jpg"><img src="images/cover.jpg" alt="" /></a></p>
<!-- Named page links below: /-->
<h1><a class="header" href="#lfe-machine-manual" id="lfe-machine-manual">LFE MACHINE MANUAL</a></h1>
<br/>
<br/>
<br/>
<br/>
<br/>
<p>Adatped from multiple sources
<br/>
by Duncan McGreggor and Robert Virding</p>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<p><a href="http://cnbb.pub/"><img src="fm/../images/cnbb-pub-logo-1.6.png" alt="publisher logo" /></a></p>
<!-- Named page links below: /-->
<p>Published by Cowboys 'N' Beans Books</p>
<p><a href="https://github.com/cnbbooks">https://github.com/cnbbooks</a> ◈ <a href="http://cnbb.pub/">http://cnbb.pub/</a> ◈ <a href="mailto:info@cnbb.pub">info@cnbb.pub</a></p>
<br/>
<br/>
<br/>
<p>First electronic edition published: 2020</p>
<br/>
<br/>
<br/>
<p>Portions © 1974, David Moon</p>
<p>Portions © 1978-1981, Daniel Weinreb and David Moon</p>
<p>Portions © 1979-1984, Douglas Adams</p>
<p>Portions © 1983, Kent Pitman</p>
<p>Portions © 1992-1993, Peter Norvig and Kent Pitman</p>
<p>Portions © 2003-2020, Ericsson AB</p>
<p>Portions © 2008-2012, Robert Virding</p>
<p>Portions © 2010-2020, Steve Klabnik and Carol Nichols</p>
<p>Portions © 2013-2020, Robert Virding and Duncan McGreggor</p>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></p>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License" /></a></p>
<br/>
<br/>
<br/>
<h1><a class="header" href="#preface" id="preface">Preface</a></h1>
<p>The original Lisp Machine Manual, the direct spiritiaul ancestor of the LFE Machine Manual, described both the language and the &quot;operating system&quot; of the Lisp Machine. The language was a dialect of Lisp called Zetalisp. Zetalisp was a direct descendant of MACLISP, created as a systems programming language for the MIT Lisp machines. This is of special note since Erlang was created as a systems programming language too. One of it's co-creators, Robert Virding, created Lisp Flavoured Erlang (LFE) based upon his expereinces with Franz Lisp (which based largely upon MACLISP), Portable Standard Lisp (itself an experiment in systems programming), and ultimately in an implementation he made of Lisp Machine Flavors on top of VAX/VMS where he extensively utilized the Lisp Machine Manual.</p>
<p>As such, LFE has a very strong inheritance of systems programming from both parents, as it were. First and foremost, it is a BEAM language written on top of the Erlang VM and from which it strays very little. Secondly, it is a Lisp dialect. It is, however, <em>entirely</em> a systems programming language.</p>
<p>Which brings us back to Zetalisp and the Lisp Machine Manual. It seemed only fitting to base the LFE manual upon the fantastic work and docuentation that was done on Lisp systems programming in the 70s and 80s, work that so many of us treasure and adore and to which we still defer. Thus the machine that is OTP in the context and syntax of the LFE Lisp dialect is extensively documented in the LFE MACHINE MANUAL.</p>
<h1><a class="header" href="#about-the-cover" id="about-the-cover">About the Cover</a></h1>
<p>The LFE &quot;Chineual&quot; cover is based upon the Lisp Machine Manual covers of the early 80s. The Lisp Machine Manual editions we have seen from 1977 and 1979 had only hand-typed title pages, no covers, so we're not sure if the famous graphic/typographic design occurred any earlier than 1982. We've also been unable to discover who the original designer was, but would love to give them credit, should we find out.</p>
<h2><a class="header" href="#the-original" id="the-original">The Original</a></h2>
<p>The Software Preservation Group has this image on their site:</p>
<p><a href="http://www.softwarepreservation.org/projects/LISP/images/LispMachineManual.gif/view"><img src="preface/../images/chinuel-cover-bw.png" alt="" /></a></p>
<p>Bitsavers has a 3rd edition of the Chineual with the full cover</p>
<p><a href="http://www.bitsavers.org/pdf/mit/cadr/chinual_3rdEd_Mar81.pdf"><img src="preface/../images//chinuel-cover-full-color.png" alt="" /></a></p>
<h2><a class="header" href="#the-lfe-edition" id="the-lfe-edition">The LFE Edition</a></h2>
<h3><a class="header" href="#whole-cover" id="whole-cover">Whole Cover</a></h3>
<p><a href="preface/../images/cover-all-large.jpg"><img src="preface/../images/cover-all.jpg" alt="" /></a></p>
<h3><a class="header" href="#back-cover" id="back-cover">Back Cover</a></h3>
<p><a href="preface/../images/cover-back-large.jpg"><img src="preface/../images/cover-back.jpg" alt="" /></a></p>
<h3><a class="header" href="#the-spine" id="the-spine">The Spine</a></h3>
<p><a href="preface/../images/cover-binding-large.jpg"><img src="preface/../images/cover-binding.jpg" alt="" /></a></p>
<!-- Named page links below: /-->
<h1><a class="header" href="#dedication" id="dedication">Dedication</a></h1>
<p>TBD</p>
<h1><a class="header" href="#forward" id="forward">Forward</a></h1>
<p>TBD</p>
<h1><a class="header" href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p>TBD</p>
<p>[gonna be a long list ...]</p>
<h1><a class="header" href="#part-i" id="part-i">PART I</a></h1>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Far out in the uncharted backwaters of the unfashionable end of computer science known as &quot;distributed systems programming&quot; lies a small red <em>e</em>. Orbitting this at a distance roughly proportional to the inverse of the likelihood of it being noticed is an utterly insignificant little green mug filled with the morning beverage stimulant equivalent of That Old Janx Spirit. Upon that liquid floats a little yellow <em>𝛌</em> whose adherents are so amazingly primitive that they still think <code>cons</code>s, <code>car</code>, and <code>cdr</code> are pretty neat ideas.</p>
<p>This is their book.</p>
<p>Their language, Lisp Flavoured Erlang (henceforth &quot;LFE&quot;), lets you use the archaic and much-beloved S-expressions to write some of the most advanced software on the planet. LFE is a general-purpose, concurrent, functional Lisp whose underlying virtual machine (Erlang) was designed to create distributed, fault-tolerant, soft-realtime, highly-availale, always-up, hot-swappable appliances, applications, and services. In addition to fashionable digital watches, LFE sports immutable data, pattern-matching, eager evaluation, and dynamic typing.</p>
<p>This manual will not only teach you what all of that means and why you want it in your breakfast cereal, but also: how to create LFE programs; what exactly are the basic elements of the language; the ins-and-outs of extremely efficient and beautiful clients and servers; and much, much more.</p>
<p>Note, however, that the first chapter is a little different than most other books, and is in fact different from the rest of the chapters in this manual. We wrote this chapter with two guiding thoughts: firstly and foremost, we wanted to provide some practical examples of code-in-action as a context in which a programmer new to LFE could continuously refer -- from the very beginning through to the successful end --  while learning the general principles of that language; secondly, most programming language manuals are dry references to individual pieces of a language or system, not representatives of the whole, and we wanted to provide a starting place for those who learn well via examples, who <em>would</em> benefit from a view toward that whole. For those who have already seen plenty of LFE examples, don't need this, and would rather get to down to the nitty-gritty, rest assured we desire your experience to be guilt-free and thus encourage you to jump into next chapter immediately!</p>
<p>This book is divided into 6 parts with the following foci:</p>
<ul>
<li>Introductory material</li>
<li>Core data types and capabilities</li>
<li>The basics of LFE code and projects</li>
<li>Advanced language features</li>
<li>The machine that is OTP</li>
<li>Concluding thoughts and summaries</li>
</ul>
<p>There is a lot of material in this book, so just take it section by section. If at any time you feel overwhelmed, simply set down the book, take a deep breath, fix yourself a cuppa, and don't panic.</p>
<p>Welcome to the LFE MACHINE MANUAL, the definitive LFE reference.</p>
<h1><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h1>
<p>Anyone coming to LFE should have experience programming in another language, ideally a systems programming language, especially if that language was found lacking. If the corageous reader is attmping to use LFE as a means of entering the study of computer science, we might offer several <em>other</em> paths of study which may bear fruit more quickly and with less pain.</p>
<p>No prior Lisp experience is required, but that would certinaly be helpful. The same goes for Erlang/OTP (or any of the suite of BEAM languages). The reader with experience writing concurrent applications, wrestling with fault-tolerance, or maintaining highly-available applications and services does receive bonus points for preparedness. Such well-prepared readers landing here may have, in fact, done so due to a quest for a distributed Lisp. For those whom this does apply, your quest has found its happy end.</p>
<p>This book assumes the reader has the following installed upon their system:</p>
<ul>
<li>a package manager for easily installing software (in particular, development tools and supporting libraries)</li>
<li><code>git</code>, <code>make</code>, and other core open source software development tools</li>
<li>a modern version of Erlang (as of the writing of this book, that would include versions 19 through 23); the rebar3 documentation has <a href="https://www.rebar3.org/docs/getting-started#installing-erlang">great suggestions</a> on what to use here, depending upon your need</li>
<li>the <code>rebar3</code> build tool for Erlang (and other BEAM languages); see <a href="https://www.rebar3.org/docs/getting-started#installing-binary">its docs</a> for installation instructions</li>
</ul>
<h1><a class="header" href="#conventions" id="conventions">Conventions</a></h1>
<h2><a class="header" href="#typography" id="typography">Typography</a></h2>
<h3><a class="header" href="#key-entry" id="key-entry">Key Entry</a></h3>
<p>We use the angle bracket convention to indicate typing actual key on the keyboard. For instance, when the reader sees <code>&lt;ENTER&gt;</code> they should interpret this as an actual key they should type. Note that all keys are given in upper-case. If the reader is expected to use an upper-case &quot;C&quot;  instead of a lower-case &quot;c&quot;, they will be presented with the key combination <code>&lt;SHIFT&gt;&lt;C&gt;</code>.</p>
<h3><a class="header" href="#code" id="code">Code</a></h3>
<p>Color syntax highlighting is used in this text to display blocks of code. The formatting of this display is done in such a way as to invoke in the mind of the reader the feeling of a terminal, thus making an obvious visual distinction in the text. For instance:</p>
<pre><code class="language-lisp">(defun fib
  ((0) 0)
  ((1) 1)
  ((n)
    (+ (fib (- n 1))
       (fib (- n 2)))))
</code></pre>
<p>Examples such as this one are readily copied and may be pasted without edit into a file or even the LFE REPL itself.</p>
<p>For interactive code, we display the default LFE prompt the reader will see when in the REPL:</p>
<pre><code class="language-lisp">lfe&gt; (integer_to_list 42 2)
;; &quot;101010&quot;
</code></pre>
<p>We also distinguish the output from the entered LFE code using code comments displayed afer the command.</p>
<p>For shell commands, the commands to enter at the prompt are prefixed by a <code>$</code> for the prompt. Input and any relevant output are provided as comment strings:</p>
<pre><code class="language-bash">$ echo &quot;I am excited to learn LFE&quot;
# I am excited to learn LFE
</code></pre>
<h2><a class="header" href="#liffybot" id="liffybot">LiffyBot</a></h2>
<p><img class="liffy-bot-mascot" src="part1/intro/../../images/LiffyBot-5-x500-bold-color.png"/>This is a severly hoopy frood. With an attitude. He pops up from time to time, generally with good advice. Or simply as a marker for something the authors hope you will pay special note.</p>
<br/>
<h2><a class="header" href="#messages-of-note" id="messages-of-note">Messages of Note</a></h2>
<p>From time to time you will see call-out boxes, aimed at drawing your attention to something of note. There are four differnt types of these:</p>
<ul>
<li>ones that share useful info (blue)</li>
<li>ones that highlight something of a momentus nature (green)</li>
<li>ones that offer warnings to tred carefully (orange)</li>
<li>ones that beg you not to follow a particular path (red)</li>
</ul>
<p>These messages will take the following forms:</p>
<div class="alert alert-info">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    Information
  </h4>
  <p class="mb-0">
    Here you will see a message of general interest that could have a useful or even positive impact on your experience in programming LFE.
<p>The icon associated with this type of message is the &quot;i&quot; in a circle.</p>
</p>
</div>
<br/>
<div class="alert alert-success">
  <h4 class="alert-heading">
    <img class="liffy-bot-alert" src="part1/intro/../../images/LiffyBot-5-x64-bold-black-solid.png"/>
    Amazing!
  </h4>
  <p class="mb-0">
    Here you will see a message of general celebration for sitations that warrant it, above and beyond the general celebration you will feel writing programs in a distributed Lisp.
<p>The icon assocated with this type of message is that of LiffyBot.</p>
</p>
</div>
<br/>
<div class="alert alert-warning">
  <h4 class="alert-heading">
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
    Warning!
  </h4>
  <p class="mb-0">
    Here you will see a message indicating a known isssue or practice you should avoid if possible.
<p>The icon assocated with this type of message is the &quot;!&quot; in a caution triangle.</p>
</p>
</div>
<br/>
<div class="alert alert-danger">
  <h4 class="alert-heading">
    <i class="fa fa-minus-circle" aria-hidden="true"></i>
    Danger!
  </h4>
  <p class="mb-0">
    Here you will see a message indicating something that could endanger the proper function of an LFE system or threaten the very existence of the universe itself.
<p>The icon assocated with this type of message is &quot;do not enter&quot;.</p>
</p>
</div>
<h1><a class="header" href="#development-setup" id="development-setup">Development Setup</a></h1>
<h2><a class="header" href="#rebar3-configuration" id="rebar3-configuration"><code>rebar3</code> Configuration</a></h2>
<p>Having followed the notes and linked instructions in the <a href="part1/intro/prereq.html">Prerequisites</a> section, you are ready to add global support for the LFE <code>rebar3</code> plugin.</p>
<p>First, unless you have configured other <code>rebar3</code> plugins on your system, you will need to create the configuration directory and the configuration file:</p>
<pre><code class="language-bash">$ mkdir ~/.config/rebar3
$ touch ~/.config/rebar3/rebar.config
</code></pre>
<p>Next, open up that file in your favourite editor, and give it these contents:</p>
<pre><code class="language-erlang">{plugins, [
  {rebar3_lfe,
    {git, &quot;https://github.com/lfe-rebar3/rebar3_lfe.git&quot;, {branch, &quot;master&quot;}}}
]}.
</code></pre>
<p>If you already have a <code>rebar.config</code> file with a plugins entry, then simply add a comma after the last plugin listed and paste the <code>{rebar3_lfe, {...}}</code> line from above (with no trailing comma!).</p>
<div class="alert alert-warning">
  <h4 class="alert-heading">
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
    For Windows users
  </h4>
  <p class="mb-0">
    XXX
  </p>
</div>
<div class="alert alert-info">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    For Windows users
  </h4>
  <p class="mb-0">Some notes on compatibility:</p>
  <p class="mb-0">
    While LFE, Erlang, and <code>rebar3</code> work on *NIX, BSD, and Windows systems, much of the development the community does occurs predominently on the first two and sometimes Windows support is spotty and less smooth than on the more used platforms (this is more true for <code>rebar3</code> and LFE, and _most_ true for LFE).
<p>In particular, starting a REPL in Windows can take a little more effort (an extra step or two) than it does on, for example, Linux and Mac OS X machines.</p>
</p>
</div>
<h2><a class="header" href="#a-quick-test-with-the-repl" id="a-quick-test-with-the-repl">A Quick Test with the REPL</a></h2>
<p>With the LFE <code>rebar3</code> plugin successfully configured, you should be able to start up the LFE REPL anywhere on your system with the following:</p>
<pre><code class="language-shell">$ rebar3 lfe repl
</code></pre>
<pre><code class="language-text">Erlang/OTP 23 [erts-11.0] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:1] [hipe]

   ..-~.~_~---..
  (      \\     )    |   A Lisp-2+ on the Erlang VM
  |`-.._/_\\_.-':    |   Type (help) for usage info.
  |         g |_ \   |
  |        n    | |  |   Docs: http://docs.lfe.io/
  |       a    / /   |   Source: http://github.com/rvirding/lfe
   \     l    |_/    |
    \   r     /      |   LFE v1.3-dev (abort with ^G)
     `-E___.-'

lfe&gt;
</code></pre>
<p>Exit out of the REPL for now by typing <code>&lt;CTRL&gt;&lt;G&gt;</code> and  thn <code>&lt;Q&gt;</code>.</p>
<div class="alert alert-warning">
  <h4 class="alert-heading">
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
    For Windows users
  </h4>
  <p class="mb-0">
    On Windows, this currently puts you into the Erlang shell, not the LFE REPL. To continue to the LFE REPL, you will need to enter <code>lfe_shell:server().</code> and then press <code>&lt;ENTER&gt;</code>.
  </p>
</div>
<h1><a class="header" href="#hello-world" id="hello-world">'Hello, World!'</a></h1>
<p>Hello-World style introductory programs are intended to give the potential programmer for that language a sense of what it is like to write a minimalist piece of software with the language in question. In particular, it should show off the minimum capabilitiues of the language, essentially, what you could be in for should you decide upon this path.</p>
<p>In the case of LFE/OTP, this is extremely misleading. But more on that in the OTP version of the Hello-World program.</p>
<p>In this section we will concede to conventional practice and produce a minimal Hello-World that does what many other languages' Hello-World programs do.</p>
<h1><a class="header" href="#from-the-repl" id="from-the-repl">From the REPL</a></h1>
<p>As previously demonstrated, it is possible to start up the LFE 'read-eval-print loop' (REPL) using <code>rebar3</code>:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>Once you are at the LFE prompt, you may write a simple LFE &quot;program&quot; like the following:</p>
<pre><code class="language-lisp">lfe&gt; (io:format &quot;~p~n&quot; (list &quot;Hello, World!&quot;))
</code></pre>
<p>Or, for the terminally lazy:</p>
<pre><code class="language-lisp">lfe&gt; (io:format &quot;~p~n&quot; '(&quot;Hello, World!&quot;))
</code></pre>
<p>While technically a program, it is not a very interesting one: we didn't create a function of our own, nor did we run it from outside the LFE interactive programming environment.</p>
<p>Let's address one of those points right now. Try this:</p>
<pre><code class="language-lisp">lfe&gt; (defun hello-world ()
lfe&gt;   (io:format &quot;~p~n&quot; '(&quot;Hello, World!&quot;)))
</code></pre>
<p>This is a simple function definition in LFE.</p>
<p>We can run it by calling it:</p>
<pre><code class="language-lisp">lfe&gt; (hello-world)
;; &quot;Hello, World!&quot;
;; ok
</code></pre>
<p>When we execute our <code>hello-world</code> function, it prints our message to <code>standard-output</code> and then lets us know everything really quite fine with a friendly <code>ok</code>. LFE displays <code>ok</code> as output for functions that do not return a value.</p>
<p>Now let's address the other point: running a Hello-World programming from outside LFE.</p>
<p>Hit <code>&lt;CTRL-G&gt;&lt;Q&gt;</code> to exit the REPL and get back to your terminal.</p>
<h1><a class="header" href="#from-the-command-line" id="from-the-command-line">From the Command Line</a></h1>
<p>From your system shell prompt, run the following to create a new project that will let us run a Hello-World program from the command line:</p>
<pre><code class="language-bash">$ rebar3 new lfe-main hello-world
$ cd ./hello-world
</code></pre>
<p>Once in the project directory, you can actually just do this:</p>
<pre><code class="language-bash">$ rebar3 lfe run
</code></pre>
<p>You will see code getting downloaded and compiled, and then your script will run, generating the following output:</p>
<pre><code class="language-text">Running script '/usr/local/bin/rebar3' with args [] ...
'hello-world
</code></pre>
<p>When you created a new LFE project of type 'main', a Hello-World function was automatically generated for you, one that's even simpler than what we created in the previous section:</p>
<pre><code class="language-lisp">(defun my-fun ()
  'hello-world)
</code></pre>
<p>The other code that was created when we executed <code>rebar3 new lfe-main hello-world</code> was a script meant to be used by LFE with LFE acting as a shell interpreter:</p>
<pre><code class="language-lisp">#!/usr/bin/env lfescript

(defun main (args)
  (let ((script-name (escript:script_name)))
    (io:format &quot;Running script '~s' with args ~p ...~n&quot; `(,script-name ,args))
    (io:format &quot;~p~n&quot; `(,(hello-world:my-fun)))))
</code></pre>
<p>You may be wondering about the <code>args</code> argument to the <code>main</code> function, and the fact that the printed output for the <code>args</code> when we ran this was <code>[]</code>. Let's try something:</p>
<pre><code class="language-bash">$ rebar3 lfe run -- Fenchurch 42
</code></pre>
<pre><code class="language-text">Running script '/usr/local/bin/rebar3' with args [&lt;&lt;&quot;Fenchurch&quot;&gt;&gt;,&lt;&lt;&quot;42&quot;&gt;&gt;] ...
'hello-world'
</code></pre>
<p>We have to provide the two dashes to let <code>rebar3</code> know that we're done with it, that the subsequent argsuments are not for it, but rather for the program we want it to start for us. Using it causes everything after the <code>--</code> to be passed as arguments to our script.</p>
<p>As for the code itself, it's tiny. But there is a lot going on just with these two files. Have no fear, though: the remainder of this book will explore all of that and more. For now, know that the main function in the executable is calling the <code>hello-world</code> module's <code>my-fun</code> function, which takes no arguments. To put another way, what we really have here is a tiny, trivial library project with the addition of a script that calls a function from that library.</p>
<p>For now just know that an executable file which starts with <code>#!/usr/bin/env lfescript</code> and contains a <code>main</code> function accepting one argument is an LFE script capable of being executed from the command line -- a we have shown!</p>
<h1><a class="header" href="#lfeotp-hello-world" id="lfeotp-hello-world">LFE/OTP 'Hello, World!'</a></h1>
<p>What have been demonstrated so far are fairly vanilla Hello-World examples; there's nothing particularly interesting about them, which puts them solidly iin the company of the millions of other Hello-World programs. As mentioned before, this approach is particularly vexing in the case of LFE/OTP, since it lures the prospective developer into the preconception that BEAM languages are just like other programming languages. They most decidfedluy are not.</p>
<p>What makes them, and in this particular case LFE, special is OTP. There's really nothing quite like it, certainly not baked into the heart and soul of another programming language. Most useful applications you will write in LFE/OTP will be composed of some sort of long-running service or server, something that manages that server and restarts it in the event of errors, and lastly, a context that contains both, the latter usually referred to as the &quot;application&quot; itself.</p>
<p>As such, a <em>real</em> Hello-World in LFE would be honest and let the prospective developer know what they are in for (and what power will be placed at their fingertips). <em>That</em> is what we will show now, a <em>real</em> LFE Hello-World example.</p>
<p>If you are still in the directory of the previous Hello-World project, let's get out of that:</p>
<pre><code class="language-bash">$ cd ../
</code></pre>
<p>Now we're going to create a new project, one utilising the some very basic OTP patterns:</p>
<pre><code class="language-bash">$ rebar3 new lfe-app hello-otp-world
$ cd ./hello-otp-world
</code></pre>
<p>We won't look at the code for this right now, since there are chapters dedicated to that in the second half of the book. But let's brush the surface with a quick run in the REPL:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>To start your new hello-world application, use the OTP <code>application</code> module:</p>
<pre><code class="language-lisp">lfe&gt; (application:ensure_all_started 'hello-otp-world)
;; #(ok (hello-otp-world))
</code></pre>
<p>That message lets you know that not only was the <code>hello-otp-word</code> application and server started without issue, any applications upon which it depends were also started. Furthermore, there is a supervisor for our server, and it has started as well. Should our Hello-World server crash for any reason, the supervisor will restart it.</p>
<p>To finish the demonstration, and display the clichéd if classic message:</p>
<pre><code class="language-lisp">(hello-otp-world:echo &quot;Hello, OTP World!&quot;)
;; &quot;Hello, OTP World!&quot;
</code></pre>
<p>And that, dear reader, is a <em>true</em> LFE/OTP Hello-World program, complete with message-passing and pattern-matching!</p>
<p>Feel free to poke around in the code that was generated for you, but know that eventually all its mysteries will be revealed, and by the end of this book this program's magic will just seem like ordinary code to you, ordinary, dependable, fault-tolerant, highly-availble, massively-concurrent code.</p>
<h1><a class="header" href="#walk-through-an-lfe-guessing-game" id="walk-through-an-lfe-guessing-game">Walk-through: An LFE Guessing Game</a></h1>
<p>Now that you've seen some LFE in action, let's do something completely insane: write a whole game before we even know the language!</p>
<p>We will follow the same patterns established in the Hello-World examples, so if you are still in one of the Hello-World projects, change directory and then create a new LFE project:</p>
<pre><code class="language-bash">$ cd ../
$ rebar3 new lfe-app guessing-game
$ cd ./guessing-game
</code></pre>
<p>We will create this game by exploring functions in the REPL and then saving the results in a file. Open up your generated project in your favourite code-editing application, and then open up a terminal from your new project directory, and start the REPL:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<h1><a class="header" href="#planning-the-game" id="planning-the-game">Planning the Game</a></h1>
<p>We've created our new project, but before we write even a single atom of code, let's take a moment to think about the problem and come up with a nice solution. Byt doing this, we increase our chances of making something both useful and elegant. As long as what we write remains legible and meets our needs, the less we write the better. This sort of practice elegance will make the code easier to maintain and reduce the chance for bugs (by the simple merrit of there being less code in which a bug may arise; the more code, the greater opportunities for bugs).</p>
<p>Our first step will be making sure we understand the problem and devising some minimal abstractions. Next, we'll think about what actually need to happen in the game. With that in hand, we will know what state we need to track. Then, we're off to the races: all the code will fall right into place and we'll get to play our game.</p>
<h2><a class="header" href="#key-abstractions" id="key-abstractions">Key Abstractions</a></h2>
<p>In a guessing game, there are two players: one who has the answer, and one who seeks the answer. Our code and data should clearly model these two players.</p>
<h2><a class="header" href="#actions" id="actions">Actions</a></h2>
<p>The player with the answer needs to peform the following actions:</p>
<ol>
<li>At the beginning of the game, state the problem and tell the other player to start guessing</li>
<li>Receive the other player's guess</li>
<li>Check the guess against the answer</li>
<li>Report back to the other player on the provided guess</li>
<li>End the game if the guess was correct</li>
</ol>
<p>The guessing player needs to take only one action:</p>
<ol>
<li>guess!</li>
</ol>
<h2><a class="header" href="#state" id="state">State</a></h2>
<p>We need to track the state of the game. Based upon the actions we've examined, the overall state is very simple. Through the course of the game, will only need to preserve the answer that will be guessed.</p>
<h1><a class="header" href="#code-explore" id="code-explore">Code Explore</a></h1>
<p>Now that we've thought through our problem space clearly and cleanly, let's do some code exploration and start defining some functions we think we'll need.</p>
<p>We've already generated an OTP application using the LFE <code>rebar3</code> plugin, and once we've got our collection of functions that address the needed game features, we can plug those into the application.</p>
<p>We'll make those changes in the code editor you've opened, and we'll explore a small set of possible functions to use for this using the project REPL session you've just started.</p>
<h1><a class="header" href="#getting-user-input" id="getting-user-input">Getting User Input</a></h1>
<p>How do we get user input in LFE? Like this!</p>
<pre><code class="language-lisp">lfe&gt; (io:fread &quot;Guess number: &quot; &quot;~d&quot;)
</code></pre>
<p>This will print the prompt <code>Guess number:</code> and then await your input and the press of the <code>&lt;ENTER&gt;</code> key. The input you provide needs to match the format type given in the second argument. In this case, the <code>~d</code> tells us that this needs to be a decimal (base 10) integer.</p>
<pre><code class="language-lisp">fe&gt; (io:fread &quot;Guess number: &quot; &quot;~d&quot;)
;; Guess number: 42
;; #(ok &quot;*&quot;)
</code></pre>
<p>If we try typing something that is not a base 10 integer, we get an error:</p>
<pre><code class="language-lisp">lfe&gt; (io:fread &quot;Guess number: &quot; &quot;~d&quot;)
;; Guess number: forty-two
;; #(error #(fread integer))
</code></pre>
<p>With correct usage, how do we capture the value in a variable? The standard way to do this in LFE is destructuring via pattern matching. The following snippet extracts the value and then prints the extracted value in the REPL:</p>
<pre><code class="language-lisp">lfe&gt; (let ((`#(ok (,value)) (io:fread &quot;Guess number: &quot; &quot;~d&quot;)))
lfe&gt;   (io:format &quot;Got: ~p~n&quot; `(,value)))
;; Guess number: 42
;; Got: 42
;; ok
</code></pre>
<p>We'll talk a lot more about pattern matching in the future, as well as the meaning of the backtick and commas. For now,let's keep pottering in the REPL with these explorations, and make a function for this:</p>
<pre><code class="language-lisp">lfe&gt; (defun guess ()
lfe&gt;   (let ((`#(ok (,value)) (io:fread &quot;Guess number: &quot; &quot;~d&quot;)))
lfe&gt;     (io:format &quot;You guessed: ~p~n&quot; `(,value))))
</code></pre>
<p>And call it:</p>
<pre><code class="language-lisp">lfe&gt; (guess)
;; Guess number: 42
;; You guessed: 42
;; ok
</code></pre>
<h1><a class="header" href="#checking-the-input" id="checking-the-input">Checking the Input</a></h1>
<p>In LFE there are several ways in which you can perform checks on values:</p>
<ul>
<li>the <code>if</code> form</li>
<li>the <code>cond</code> form</li>
<li>the <code>case</code> form</li>
<li>pattern-matching and/or guards in function heads</li>
</ul>
<p>The last one is commonly used in LFE when passing messages / data between functions. Our initial, generated project code is already doing this, and given the game state data we will be working with, this feels like a good fit what we need to implement.</p>
<p>Normally records are used for application data, but since we just care about the value of two integers (the number selected for the answer and the number guessed by the player), we'll keep things simple in this game:</p>
<pre><code class="language-lisp">(set answer 42)
</code></pre>
<p>Let's create a function with a guard:</p>
<pre><code class="language-lisp">lfe&gt; (defun check
lfe&gt;   ((guess) (when (&lt; guess answer))
lfe&gt;    (io:format &quot;Guess is too low~n&quot;)))
</code></pre>
<p>The extra parenthesis around the function's arguments is due to the use of the pattern-matching form of function definition we're using here. We need this form, since we're going to use a guard. The <code>when</code> after the function args is called a &quot;guard&quot; in LFE. As you might imagine, we could use any number of these.</p>
<pre><code class="language-lisp">lfe&gt; (check 10)
;; Guess is too low
;; ok
</code></pre>
<p>Let's add some more guards for the other checks we want to perform:</p>
<pre><code class="language-lisp">lfe&gt; (defun check
lfe&gt;   ((guess) (when (&lt; guess answer))
lfe&gt;    (io:format &quot;Guess is too low~n&quot;))
lfe&gt;   ((guess) (when (&gt; guess answer))
lfe&gt;    (io:format &quot;Guess is too high~n&quot;))
lfe&gt;   ((guess) (when (== guess answer))
lfe&gt;    (io:format &quot;Correct!~n&quot;)))
</code></pre>
<pre><code class="language-lisp">lfe&gt; (check 10)
;; Guess is too low
;; ok
</code></pre>
<pre><code class="language-lisp">lfe&gt; (check 100)
;; Guess is too high
;; ok
</code></pre>
<pre><code class="language-lisp">lfe&gt; (check 42)
;; Correct!
;; ok
</code></pre>
<p>This should give a very general sense of what is possible.</p>
<h1><a class="header" href="#integrating-into-an-application" id="integrating-into-an-application">Integrating into an Application</a></h1>
<p>We're only going to touch one of the files that was generated when you created the <code>guessing-game</code> project: <code>./src/guessing-game.lfe</code>. You can ignore all the others. Once we've made all the changes summarized below, we will walk through this file at a high level, discussing the changes and how those contribute to the completion of the game.</p>
<p>First though, we need to reflect on the planning we just did, remembering the actions and states that we want to support. There's also another thing to consider, since we're writing this as is an always-up OTP app. With some adjustments for state magagement, it could easily be turned into something that literally millions of users could be accessing simultaneouslyi. So: how does a game that is usually implemented as a quick CLI toy get transformed in LFE/OTP such that it can be run as a server?</p>
<p>In short, we'll use OTP's <code>gen_server</code> capability (&quot;behaviour&quot;) and the usual message-passing practices. As such, the server will need to be able to process the following messages:</p>
<ul>
<li><code>#(start-game true)</code> (create a record to track game state)</li>
<li><code>#(stop-game true)</code> (clear the game state)</li>
<li><code>#(guess n)</code>
<ul>
<li>check for guess equal to the answer</li>
<li>greater than the answer, and</li>
<li>less than the answer</li>
</ul>
</li>
</ul>
<p>We could have just used atoms for the first two, and done away with the complexity of using tuples for those, but symmetry is nice :-)</p>
<p>To create the game, we're going to need to perform the following integration tasks:</p>
<ul>
<li>Update the <code>handle_cast</code> function to process the commands and guards we listed above</li>
<li>Create API functions that cast the appropriate messages</li>
<li>Update the <code>export</code> form in the module definition</li>
<li>Set the random seed so that the answers are different every time you start the application</li>
</ul>
<h1><a class="header" href="#handle_cast" id="handle_cast"><code>handle_cast</code></a></h1>
<p>The biggest chunk of code that needs to be changed is the <code>handle_cast</code> function. Since our game doesn't return values, we'll be using <code>handle_cast</code>. (If we needed to have data or results returned to us in the REPL, we would have used <code>handle_call</code> instead. Note that both are standard OTP <code>gen_server</code> callback functions.)</p>
<p>The generated project barely populates this function and the function isn't of the form that supports patten-matching (which we need here) so we will essentially be replacing what was generated. In the file <code>./src/guessing-game.lfe</code>, change this:</p>
<pre><code class="language-lisp">(defun handle_cast (_msg state)
  `#(noreply ,state))
</code></pre>
<p>to this:</p>
<pre><code class="language-lisp">(defun handle_cast
  ((`#(start-game true) _state)
   (io:format &quot;Guess the number I have chosen, between 1 and 10.~n&quot;)
   `#(noreply ,(random:uniform 10)))
  ((`#(stop-game true) _state)
   (io:format &quot;Game over~n&quot;)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (== n answer))
   (io:format &quot;Well-guessed!!~n&quot;)
   (stop-game)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (&gt; n answer))
   (io:format &quot;Your guess is too high.~n&quot;)
   `#(noreply ,answer))
  ((`#(guess ,n) answer) (when (&lt; n answer))
   (io:format &quot;Your guess is too low.~n&quot;)
   `#(noreply ,answer))
  ((_msg state)
   `#(noreply ,state)))
</code></pre>
<p>That is a single function in LFE, since for every match the arity of the function remains the same. It is, however, a function with six different and separate arguement-body forms: one for each pattern and/or guard.</p>
<p>These patterns are matched:</p>
<ol>
<li>start</li>
<li>stop</li>
<li>guess (three times)</li>
<li>any</li>
</ol>
<p>For the three guess patterns (well, one pattern, really) since there are three different guards we want placed on them:</p>
<ol>
<li>guess is equal</li>
<li>guess is greater</li>
<li>guess is less</li>
</ol>
<p>Note that the pattern for the function argument in these last three didn't change, only the guard is different beptween them.</p>
<p>Finally, there's the original &quot;pass-through&quot; or &quot;match-any&quot; pattern (this is used to prevent an error in the event of an unexpected message type).</p>
<h1><a class="header" href="#game-api" id="game-api">Game API</a></h1>
<p>In order to send a message to a running OTP server, you use special OTP functions for the type of server you are running. Our game is running a <code>gen_server</code> so we'll be using that OTP module to send messages, in particular we'll be calling <code>gen_server:cast</code>. However, creating messages and sending them via the appropriate <code>gen_server</code> function can get tedious quickly, so it is common practice to create API functions that do these things for you.</p>
<p>In our case, we want to go to the section with the heading <code>;;; our server API</code> and add the following:</p>
<pre><code class="language-lisp">(defun start-game ()
  (gen_server:cast (SERVER) '#(start-game true)))

(defun stop-game ()
  (gen_server:cast (SERVER) '#(stop-game true)))

(defun guess (n)
  (gen_server:cast (SERVER) `#(guess ,n)))
</code></pre>
<p>Functions in LFE are private by default, so simply adding these functions doesn't make them publicly accessible. As things now stand these will not be usable outside their module; if we want to use them, e.g., from the REPL, we need to export them.</p>
<p>Go to the top of the <code>guessing-game</code> module and update the &quot;server API&quot; sectopm of the <code>export</code>s, chaning this:</p>
<pre><code class="language-lisp">    ;; server API
    (pid 0)
    (echo 1)))
</code></pre>
<p>to this:</p>
<pre><code class="language-lisp">    ;; server API
    (pid 0)
    (echo 1)
    (start-game 0)
    (stop-game 0)
    (guess 1)))
</code></pre>
<p>The final form of your module definition should look like this:</p>
<pre><code class="language-lisp">(defmodule guessing-game
  (behaviour gen_server)
  (export
    ;; gen_server implementation
    (start_link 0)
    (stop 0)
    ;; callback implementation
    (init 1)
    (handle_call 3)
    (handle_cast 2)
    (handle_info 2)
    (terminate 2)
    (code_change 3)
    ;; server API
    (pid 0)
    (echo 1)
    (start-game 0)
    (stop-game 0)
    (guess 1)))
</code></pre>
<p>Now our game functions are public, and we'll be able to use them from the REPL.</p>
<h1><a class="header" href="#finishing-touches" id="finishing-touches">Finishing Touches</a></h1>
<p>There is one last thing we can do to make our game more interesting. Right now, the game will work. But every time we start up the REPL and kick off a new game, the same &quot;random&quot; number will be selected for the answer. In order to make things interesting, we need to generate a random seed when we initialize our server. </p>
<p>We want to only do this once, though -- not every time the game starts, and certainly not every time a user guesses! When the LFE server supervisor starts our game server, one functions is called and called only once: <code>init/1</code>. That's where we want to make the change to support a better-than-default random seed.</p>
<p>Let's change that function:</p>
<pre><code class="language-lisp">(defun init (state)
  `#(ok ,state))
</code></pre>
<p>to this:</p>
<pre><code class="language-lisp">(defun init (state)
  (random:seed (erlang:phash2 `(,(node)))
               (erlang:monotonic_time)
               (erlang:unique_integer))
  `#(ok ,state))
</code></pre>
<p>Now we're ready to play!</p>
<h1><a class="header" href="#playing-the-game" id="playing-the-game">Playing the Game</a></h1>
<p>If you are still in the REPL, quit out of it so that <code>rebar3</code> can rebuild our changed module. Then start it up again:</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>Once at the LFE propmpt, start up the application:</p>
<pre><code class="language-lisp">lfe&gt; (application:ensure_all_started 'guessing-game)
</code></pre>
<p>With the application and all of its dependencies started, we're ready to start the game and play it through:</p>
<pre><code class="language-lisp">lfe&gt; (guessing-game:start-game)
;; ok
;; Guess the number I have chosen, between 1 and 10.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 10)
;; ok
;; Your guess is too high.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 1)
;; ok
;; Your guess is too low.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 5)
;; ok
;; Your guess is too low.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 7)
;; ok
;; Your guess is too low.
</code></pre>
<pre><code class="language-lisp">lfe&gt; (guessing-game:guess 8)
;; ok
;; Well-guessed!!
;; Game over
</code></pre>
<p style="font-size: 16pt;">
<img class="liffy-bot-mascot" src="part1/intro/guessing-game/../../../images/LiffyBot-5-x500-bold-color.png"/>Success! You've just done something pretty amazing, if still mysterious: you've not only created your first <strong>OTP application</strong> running a <strong>generic server</strong>, you've successully run it through to completion! Until we can dive into all the details of what you've just seen, let's take a quick moment to review what you've done and indicate which parts of this book will provide the remaining missing pieces.
</p>
<h1><a class="header" href="#code-review" id="code-review">Code Review</a></h1>
<p>We've got the whole rest of the book ahead of us to cover much of what you've seen in the sample project we've just created with our guessing game. In the coming pages, you will revisit every aspect of what you've seen so far in lots of detail with correspondingly useful insttruction on these matters.</p>
<p>That being said, it would be unfair to not at least read through the code together and mention the high-level concepts involved. Since we only touched the code in one file, that will be the one that gets the most of our attention for this short review, but let's touch on the others here, too.</p>
<h2><a class="header" href="#project-files" id="project-files">Project Files</a></h2>
<h3><a class="header" href="#rebarconfig" id="rebarconfig"><code>rebar.config</code></a></h3>
<p>This is the file you need in every LFE project you will write in order to take advantage of the features (and time-savings!) that <code>rebar3</code> provides. For this project, the two important parts are:</p>
<ol>
<li>the entry for dependences (only LFE in this case), and</li>
<li>the plugins entry for the LFE rebar3 plugin.</li>
</ol>
<h2><a class="header" href="#source-files" id="source-files">Source Files</a></h2>
<h3><a class="header" href="#appsrc" id="appsrc"><code>.app.src</code></a></h3>
<p>This file is mostly used for application metadata. Most of what our app uses in this file is pretty self-explanatory. Every LFE application will have one of these in the project source code.</p>
<h3><a class="header" href="#guessing-game-applfe" id="guessing-game-applfe"><code>guessing-game-app.lfe</code></a></h3>
<p>This is the top-level file for our game, an OTP application. It only exports two functions: one to start the app and the other to stop it. The application is responsible for starting up whatever supervisors all your services/servers need. In the guess of this sample application, only one supervisor is needed (with a very simple supervision tree).</p>
<h3><a class="header" href="#guessing-game-suplfe" id="guessing-game-suplfe"><code>guessing-game-sup.lfe</code></a></h3>
<p>This module is a little more invloved and has all the configuration and code necessary to properly set up a supervisor for our server. When something goes wrong with our server, the restart strategy defined by our supervisor will kick in and get things back up and running again. This is one of the key secrets to OTP's wizardry, and we will be covering this in great detail later.</p>
<h3><a class="header" href="#srcguessing-gamelfe" id="srcguessing-gamelfe"><code>src/guessing-game.lfe</code></a></h3>
<p>This is the last file we'll look at, and is the one we'll cover in the most detail right now. Here's the entire content of what we created for our game:</p>
<pre><code class="language-lisp">(defmodule guessing-game
  (behaviour gen_server)
  (export
   ;; gen_server implementation
   (start_link 0)
   (stop 0)
   ;; callback implementation
   (init 1)
   (handle_call 3)
   (handle_cast 2)
   (handle_info 2)
   (terminate 2)
   (code_change 3)
   ;; server API
   (pid 0)
   (echo 1)
   (start-game 0)
   (stop-game 0)
   (guess 1)))

;;; ----------------
;;; config functions
;;; ----------------

(defun SERVER () (MODULE))
(defun initial-state () '#())
(defun genserver-opts () '())
(defun unknown-command () #(error &quot;Unknown command.&quot;))

;;; -------------------------
;;; gen_server implementation
;;; -------------------------

(defun start_link ()
  (gen_server:start_link `#(local ,(SERVER))
                         (MODULE)
                         (initial-state)
                         (genserver-opts)))

(defun stop ()
  (gen_server:call (SERVER) 'stop))

;;; -----------------------
;;; callback implementation
;;; -----------------------

(defun init (state)
  (random:seed (erlang:phash2 `(,(node)))
               (erlang:monotonic_time)
               (erlang:unique_integer))
  `#(ok ,state))

(defun handle_cast
  ((`#(start-game true) _state)
   (io:format &quot;Guess the number I have chosen, between 1 and 10.~n&quot;)
   `#(noreply ,(random:uniform 10)))
  ((`#(stop-game true) _state)
   (io:format &quot;Game over~n&quot;)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (== n answer))
   (io:format &quot;Well-guessed!!~n&quot;)
   (stop-game)
   '#(noreply undefined))
  ((`#(guess ,n) answer) (when (&gt; n answer))
   (io:format &quot;Your guess is too high.~n&quot;)
   `#(noreply ,answer))
  ((`#(guess ,n) answer) (when (&lt; n answer))
   (io:format &quot;Your guess is too low.~n&quot;)
   `#(noreply ,answer))
  ((_msg state)
   `#(noreply ,state)))

(defun handle_call
  (('stop _from state)
   `#(stop shutdown ok state))
  ((`#(echo ,msg) _from state)
   `#(reply ,msg state))
  ((message _from state)
   `#(reply ,(unknown-command) ,state)))

(defun handle_info
  ((`#(EXIT ,_from normal) state)
   `#(noreply ,state))
  ((`#(EXIT ,pid ,reason) state)
   (io:format &quot;Process ~p exited! (Reason: ~p)~n&quot; `(,pid ,reason))
   `#(noreply ,state))
  ((_msg state)
   `#(noreply ,state)))

(defun terminate (_reason _state)
  'ok)

(defun code_change (_old-version state _extra)
  `#(ok ,state))

;;; --------------
;;; our server API
;;; --------------

(defun pid ()
  (erlang:whereis (SERVER)))

(defun echo (msg)
  (gen_server:call (SERVER) `#(echo ,msg)))

(defun start-game ()
  (gen_server:cast (SERVER) '#(start-game true)))

(defun stop-game ()
  (gen_server:cast (SERVER) '#(stop-game true)))

(defun guess (n)
  (gen_server:cast (SERVER) `#(guess ,n)))
</code></pre>
<p>The beginning of the file opens with a declaration of the module: not only its name, but the public functions we want to expose as part of our API. This will be covered in Chapter XXX, section XXX.</p>
<p>Next, we have a few constant functions. Functions are necessary here due to the fact that LFE does not have global variables. This will be covered in Chapter XXX, section XXX.</p>
<p>Then we define the functions that will be used as this module's implementation of a generic OTP server. There is some boilerplate here that will be discussed when we dive into LFE/OTP. This will be covered in Chapter XXX, section XXX.</p>
<p>After that, we define the functions that are used by the OTP machinery that will run our server. Here you see several examples of pattern matching function heads in LFE, a very powerful feature that lends itself nicely to consise and expressive code. This will be covered in Chapter XXX, section XXX.</p>
<p>Lastly, we define our own API. Most of these functions simply send messages to our running server. More on this in Chapter XXX, section XXX.</p>
<h1><a class="header" href="#the-lfe-repl" id="the-lfe-repl">The LFE REPL</a></h1>
<p>We briefly introduced the REPL in the first version of the Hello-World example we wrote, stating that it was an acronym for 'read-eval-print loop' and how to start it with <code>rebar3</code>. As an LFE developer, this is one of the primnary tools -- arguably <em>the</em> most powerful -- at your disposal, so we're going to do a more thorough job of introducing its capabilities in this section.</p>
<div class="alert alert-info">
  <h4 class="alert-heading">
    <i class="fa fa-info-circle" aria-hidden="true"></i>
    Historical Note
  </h4>
  <p class="mb-0">
    The first Lisp interpreter was created sometime in late 1958 by then-grad student Steve Russell after reading John McCarthy's definition of <code>eval</code>. He had the idea that the theoretical description provided there could actually be implemented in machine code.
  </p>
  <p class="mb-0">
    It is uncertain when that expression of <code>eval</code> was first combined with <code>read</code> and <code>print</code>, though the usefulness of this might not have been very significant until video hardware began to replace teletype machines and punched cards in the 1970s.
  </p>
</div>
<p>A basic REPL can be implemented with just four functions; such an implementation could be started with the following:</p>
<pre><code class="language-lisp">(LOOP (PRINT (EVAL (READ))))
</code></pre>
<p>LFE has implemented most these functions for us already (and quite robustly), but we could create our own very limited REPL (single lines with no execution context or environment) within the LFE REPL using the following convenience wrappers:</p>
<pre><code class="language-lisp">(defun read ()
  (let* ((str (io:get_line &quot;myrepl&gt; &quot;))
         (`#(ok ,expr) (lfe_io:read_string str)))
    expr))

(defun print (result)
  (lfe_io:format &quot;~p~n&quot; `(,result)))

(defun loop (code)
  (loop (print (eval (read)))))
</code></pre>
<p>Now we can start our custom REPL inside the LFE REPL:</p>
<pre><code class="language-lisp">lfe&gt; (loop (print (eval (read))))
</code></pre>
<p>This gives us a new prompt:</p>
<pre><code class="language-lisp">myrepl&gt;
</code></pre>
<p>At this prompt we can evaluate basic LFE expressions:</p>
<pre><code class="language-lisp">myrepl&gt; (+ 1 2 3)
;; 6
myrepl&gt; (* 2 (lists:foldl #'+/2 0 '(1 2 3 4 5 6)))
;; 42
</code></pre>
<p>Note that writing an evaluator is the hard part, and we've simply re-used the LFE evaluator for this demonstration.</p>
<p>Now that we've explored some of the background of REPLs and Lisp interpreters, let's look more deeply into the LFE REPL and how to best take advantage of its power when using the machine that is LFE and OTP.</p>
<h1><a class="header" href="#core-features" id="core-features">Core Features</a></h1>
<p>In keeping with the overall herritage of LFE, its REPL is both a Lisp REPL as well as an Erlang shell. In fact, when support was added for the LFE REPL to the <code>rebar3_lfe</code> plugin, it utilised <em>all</em> of the plumbing for the Erlang shell support in <code>rebar3</code>.</p>
<p>For the developer, though, this means that the LFE REPL holds a dual set of features, multiplying the set of features available to just the Erlang shell. These features include the following support:</p>
<ul>
<li>Evaluation of Lisp S-expressions</li>
<li>Definition of functions, completely with LFE tail-recursion support</li>
<li>Definition of records and use of record-specific support functions/macros</li>
<li>Creation of LFE macros via standard Lisp-2 syntax</li>
<li>Macro examination and debugging with various expansion macros</li>
<li>The ability to start the LFE REPL in distribution mode, complete with Erlang cookie, and thus to not only access remote LFE and Erlang nodes, but to be accessed as a remote node itself (for nodes that have been granted access</li>
<li>Access to the Erlang JCL and the ability to start separate, LFE shells running concurrently</li>
</ul>
<h2><a class="header" href="#unsupported" id="unsupported">Unsupported</a></h2>
<p>The following capabilities are not supported in the LFE REPL:</p>
<ul>
<li>Module definitions; these are a file-based feature in LFE, just as with Erlang.</li>
</ul>
<h1><a class="header" href="#starting-lfe" id="starting-lfe">Starting LFE</a></h1>
<h2><a class="header" href="#the-lfe-executable" id="the-lfe-executable">The <code>lfe</code> executable</a></h2>
<p>While this book focuses upon the use of <code>rebar3</code> and its LFE plugin -- due entirely to the amount of time it saves through various features it supports -- LFE may be used quite easily without it.</p>
<p>To use LFE and its REPL without <code>rebar3</code>, you'll need to clone the repo, e.g.:</p>
<pre><code class="language-bash">$ cd ~/lab
$ git clone https://github.com/rvirding/lfe.git
$ cd lfe
</code></pre>
<p>Since you have read the earlier section on dependencies, you already have Erlang, <code>make</code>, and your system build tools installed. As such, all you have to do is run the following to build LFE:</p>
<pre><code class="language-bash">$ make
</code></pre>
<p>This will generate an executable in <code>./bin</code> and you can start the LFE REPL by calling it:</p>
<pre><code class="language-bash">$ ./bin/lfe
</code></pre>
<pre><code class="language-text">Erlang/OTP 23 [erts-11.0.2] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [hipe] [dtrace]

   ..-~.~_~---..
  (      \\     )    |   A Lisp-2+ on the Erlang VM
  |`-.._/_\\_.-':    |   Type (help) for usage info.
  |         g |_ \   |
  |        n    | |  |   Docs: http://docs.lfe.io/
  |       a    / /   |   Source: http://github.com/rvirding/lfe
   \     l    |_/    |
    \   r     /      |   LFE v1.3-dev (abort with ^G)
     `-E___.-'

lfe&gt;
</code></pre>
<p>If you opt to install LFE system-wide with <code>make install</code>, then you can start the REPL from anywhere by simply executing <code>lfe</code>.</p>
<h2><a class="header" href="#via-rebar3-lfe-repl" id="via-rebar3-lfe-repl">Via <code>rebar3 lfe repl</code></a></h2>
<p>As demonstrated earlier on several occasions, you can start the LFE REPL with the <code>rebar3</code> LFE plugin (and this is what we'll do in the rest of this manual):</p>
<pre><code class="language-bash">$ rebar3 lfe repl
</code></pre>
<p>Since you have updated your global rebar3 settings (in the &quot;Prerequisites&quot; section, after following the instructions on the <code>rebar3</code> site), you may also start the LFE REPL from anywhere on your machine using the <code>rebar3</code> command.</p>
<h1><a class="header" href="#readline-support" id="readline-support"><code>readline</code> Support</a></h1>
<h2><a class="header" href="#history" id="history">History</a></h2>
<h2><a class="header" href="#tab-completion" id="tab-completion">Tab-Completion</a></h2>
<h1><a class="header" href="#help" id="help"><code>(help)</code></a></h1>
<p>As you gain familiarity with the LFE REPL, one of the most useful and convenient references will be the summary of functions, commands, and variablese that come with the LFE REPL.</p>
<p>To see these, simple call the <code>help</code> or <code>h</code> function:</p>
<pre><code class="language-lisp">lfe&gt; (help)
</code></pre>
<p>That will result in the following being displyed to your terminal:</p>
<pre><code class="language-lisp">LFE shell built-in functions

(c file)       -- compile and load code in &lt;file&gt;
(cd dir)       -- change working directory to &lt;dir&gt;
(clear)        -- clear the REPL output
(doc mod)      -- documentation of a module
(doc mod:mac)  -- documentation of a macro
(doc m:f/a)    -- documentation of a function
(ec file)      -- compile and load code in erlang &lt;file&gt;
(ep expr)      -- print a term in erlang form
(epp expr)     -- pretty print a term in erlang form
(exit)         -- quit - an alias for (q)
(flush)        -- flush any messages sent to the shell
(h)            -- an alias for (help)
(help)         -- help info
(i)            -- information about the system
(i pids)       -- information about a list of pids
(l module)     -- load or reload &lt;module&gt;
(ls)           -- list files in the current directory
(ls dir)       -- list files in directory &lt;dir&gt;
(m)            -- which modules are loaded
(m mod)        -- information about module &lt;mod&gt;
(p expr)       -- print a term
(pp expr)      -- pretty print a term
(pid x y z)    -- convert &lt;x&gt;, &lt;y&gt; and &lt;z&gt; to a pid
(pwd)          -- print working directory
(q)            -- quit - shorthand for init:stop/0
(regs)         -- information about registered processes

LFE shell built-in commands

(reset-environment)             -- reset the environment to its initial state
(run file)                      -- execute all the shell commands in a &lt;file&gt;
(set pattern expr)
(set pattern (when guard) expr) -- evaluate &lt;expr&gt; and match the result with
                                   pattern binding
(slurp file)                    -- slurp in a LFE source &lt;file&gt; and makes
                                   everything available in the shell
(unslurp)                       -- revert back to the state before the last
                                   slurp

LFE shell built-in variables

+/++/+++      -- the tree previous expressions
*/**/***      -- the values of the previous expressions
-             -- the current expression output
$ENV          -- the current LFE environment

ok
</code></pre>
<p>Most of those are documented in stdlib reference for their <a href="http://erlang.org/doc/man/c.html">Erlang counterparts</a>, so be sure to reference that information for details on many of the above.</p>
<p>Those not covered in that Erlang reference manual, or those that are different in their LFE versionsm, include:</p>
<ul>
<li>Built-in Functions
<ul>
<li>Compilation functions</li>
<li>LFE code documentation</li>
<li>Printing and pretty-printing</li>
</ul>
</li>
<li>Built-in commands</li>
<li>Built-in variables</li>
</ul>
<h1><a class="header" href="#repl-functions" id="repl-functions">REPL Functions</a></h1>
<p>Most of the LFE REPL functions are documented in stdlib reference for their <a href="http://erlang.org/doc/man/c.html">Erlang counterparts</a>. This section documents where the LFE REPL help diverges from the Erlang Shell help.</p>
<h2><a class="header" href="#compilation" id="compilation">Compilation</a></h2>
<p>If you view the Erlang reference manual documentation for compiling files in the shell, you will see differences from what is show in the LFE help text. In particular, <code>(c)</code> is for compiling LFE modules and <code>(ec)</code> needs to be used for compiling Erlang source files.</p>
<p>In both cases, the resulting <code>.beam</code> files are compiled to the current working directory and not to an <code>ebin</code> directory. These <code>.beam</code> files will be found by LFE, since the current working directory is included in the path, but you'll likely want to perform some cleanup afterward.</p>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>You may access the documentation for LFE modules, macros, and functions in the REPL via the <code>doc</code> function. For instance, the Common Lisp compatibility module's documentation:</p>
<pre><code class="language-lisp">lfe&gt; (doc cl)
;; ____________________________________________________________
;; cl
;;
;; LFE Common Lisp interface library.
;;
;; ok
</code></pre>
<p>That module's <code>cond</code> macro documentation:</p>
<pre><code class="language-lisp">lfe&gt; (doc cl:cond)
;; ____________________________________________________________
;; cond
;; args
;; CL compatible cond macro.
;;
;; ok
</code></pre>
<p>That module's <code>pairlis/2</code> function documentation:</p>
<pre><code class="language-lisp">lfe&gt; (doc cl:pairlis/2)
;; ____________________________________________________________
;; pairlis/2
;; keys values
;; Make an alist from pairs of keys values.
;;
;; ok
</code></pre>
<p>Documentation for Erlang modules and fucntions is available via the <a href="part1/repl/c.html">Command Interface</a></p>
<h2><a class="header" href="#printing-data" id="printing-data">Printing Data</a></h2>
<h3><a class="header" href="#lfe-formatting" id="lfe-formatting">LFE Formatting</a></h3>
<p>LFE provides some nice convenience functions for displaying data structions in the REPL. Let's say we had a data structure defined thusly:</p>
<pre><code class="language-lisp">lfe&gt; (set data `(#(foo bar baz) #(quux quuz) #(corge grault garply)
lfe&gt; #(plugh xyzzy) #(flurb nirf) #(zobod zirfid)))
</code></pre>
<p>We can print our data with the following:</p>
<pre><code class="language-lisp">lfe&gt; (p data)
;; (#(foo bar baz) #(quux quuz) #(corge grault garply) #(plugh xyzzy) #(flurb nirf) #(zobod zirfid))
;; ok
</code></pre>
<p>Or we can pretty-print it:</p>
<pre><code class="language-lisp">lfe&gt; (pp data)
;;(#(foo bar baz)
;; #(quux quuz)
;; #(corge grault garply)
;; #(plugh xyzzy)
;; #(flurb nirf)
;; #(zobod zirfid))
;; ok
</code></pre>
<h3><a class="header" href="#erlang-formatting" id="erlang-formatting">Erlang Formatting</a></h3>
<p>The same may be done for displaying data in the Erlang format:</p>
<pre><code class="language-lisp">lfe&gt; (ep data)
;; [{foo,bar,baz},{quux,quuz},{corge,grault,garply},{plugh,xyzzy},{flurb,nirf},{zobod,zirfid}]
;; ok
</code></pre>
<pre><code class="language-lisp">lfe&gt; (epp data)
;; [{foo,bar,baz},
;;  {quux,quuz},
;;  {corge,grault,garply},
;;  {plugh,xyzzy},
;;  {flurb,nirf},
;;  {zobod,zirfid}]
;; ok
</code></pre>
<h1><a class="header" href="#repl-commands" id="repl-commands">REPL Commands</a></h1>
<p>The LFE REPL provides several useful commands users:</p>
<pre><code class="language-lisp">(reset-environment)             -- reset the environment to its initial state
(run file)                      -- execute all the shell commands in a &lt;file&gt;
(set pattern expr)
(set pattern (when guard) expr) -- evaluate &lt;expr&gt; and match the result with
                                   pattern binding
(slurp file)                    -- slurp in a LFE source &lt;file&gt; and makes
                                   everything available in the shell
(unslurp)                       -- revert back to the state before the last
                                   slurp
</code></pre>
<p>These are fairly self-explanatory, with the possible exception of clarifying how <code>run</code> and <code>slurp</code> differ:</p>
<ul>
<li>Calling <code>(run &quot;some/file.lfe&quot;)</code> will cause the LFE REPL to read the contents of that file and then execute every line in that file as if they had been typed at the terminal. This is a convenient way of duplicating REPL state between sessions. (If you haven't kept track of your entries, you can always open up your <a href="part1/repl/readline.html">BEAM history file</a> and create an <code>.lfe</code> file with all the required commands!)</li>
<li>Calling <code>(slurp &quot;some/other/file.lfe&quot;)</code> will place all functions, records, and macros defined in that file into the LFE environment, allowing you to call them without a <code>module:</code> prefix. Note that the code is not executed, but is instead placed into the current environment, ready for use.</li>
</ul>
<h1><a class="header" href="#special-variables" id="special-variables">Special Variables</a></h1>
<pre><code class="language-lisp">LFE shell built-in variables

+/++/+++      -- the tree previous expressions
*/**/***      -- the values of the previous expressions
-             -- the current expression output
$ENV          -- the current LFE environment
</code></pre>
<p>Most of these variables are taken directly from Common Lisp and have the same exact meaning. From the Common Lisp HyperSpec for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_pl_plp.htm"><code>+,++,+++</code></a>:</p>
<blockquote>
<p>The variables +, ++, and +++ are maintained by the Lisp read-eval-print loop to save forms that were recently evaluated.</p>
<p>The value of + is the last form that was evaluated, the value of ++ is the previous value of +, and the value of +++ is the previous value of ++.</p>
</blockquote>
<p>And for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v__stst_.htm"><code>*,**,***</code></a>:</p>
<blockquote>
<p>The variables *, **, and *** are maintained by the Lisp read-eval-print loop to save the values of results that are printed each time through the loop.</p>
<p>The value of * is the most recent primary value that was printed, the value of ** is the previous value of *, and the value of *** is the previous value of **.</p>
</blockquote>
<p>Lastly, for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v__.htm"><code>-</code></a>:</p>
<blockquote>
<p>The value of - is the form that is currently being evaluated by the Lisp read-eval-print loop.</p>
</blockquote>
<p>The <code>$ENV</code> variable in the LFE REPL is a critical tool for debugging particularly tricky issues in the REPL (especially useful when creating complex macros).</p>
<h1><a class="header" href="#command-interface" id="command-interface">Command Interface</a></h1>
<p>While many of the functions listed in the LFE <code>(help)</code> have their documentation in the <a href="http://erlang.org/doc/man/c.html">Erlang Command Interface module</a> (CIM), not everything in the CIM has been provided in the LFE REPL, some of which can be useful at times.</p>
<p>Here are some of the more useful functions you may with to be aware of from that module:</p>
<ul>
<li><code>(c:bt pid)</code> - Stack backtrace for a process. Equivalent to <code>(erlang:process_display pid 'backtrace)</code>.</li>
<li><code>(c:h mod)</code> - Print the documentation for <code>mod</code></li>
<li><code>(c:h mod fun)</code> - Print the documentation for all <code>mod:fun</code></li>
<li><code>(c:h mod fun arity)</code> - Print the documentation for <code>mod:fun/arity</code></li>
<li><code>(c:lm)</code> - Reloads all currently loaded modules that have changed on disk (see <code>(c:mm)</code>). Returns the list of results from calling <code>(l mod)</code> for each such loaded module.</li>
<li><code>(c:memory)</code> - Memory allocation information. Equivalent to <code>(erlang:memory)</code>.</li>
<li><code>(c:mm)</code> -</li>
<li><code>(c:ni)</code> - Display system information, listing information about all nodes on the network</li>
<li><code>(c:nl mod)</code> - Loads Module on all nodes</li>
<li><code>(c:nregs)</code> - Displays information about all registered processes for all nodes in the network.</li>
<li><code>(c:uptime)</code> - Prints the node uptime (as specified by <code>(erlang:statistics 'wall_clock)</code>) in human-readable form.</li>
<li><code>(c:xm mod)</code> - Finds undefined functions, unused functions, and calls to deprecated functions in a module by calling xref:m/1.</li>
</ul>
<h1><a class="header" href="#job-control" id="job-control">Job Control</a></h1>
<p>When in the LFE REPL, a special mode is accessible upon typing <code>&lt;CTRL-G&gt;</code>:</p>
<pre><code>lfe&gt;
User switch command
 --&gt;
</code></pre>
<p>At the JCL <code>--&gt;</code> prompt, you may get help text by typing <code>?</code>:</p>
<pre><code class="language-text"> --&gt; ?
  c [nn]            - connect to job
  i [nn]            - interrupt job
  k [nn]            - kill job
  j                 - list all jobs
  s [shell]         - start local shell
  r [node [shell]]  - start remote shell
  q                 - quit erlang
  ? | h             - this message
 --&gt;
</code></pre>
<h2><a class="header" href="#running-multiple-shells" id="running-multiple-shells">Running Multiple Shells</a></h2>
<p>[ also: custom prompts ]</p>
<h1><a class="header" href="#primitive-types" id="primitive-types">Primitive Types</a></h1>
<p>This chapter covers the basic types of data available to LFE, upon which primatives rest LFE libraries and applications.</p>
<ul>
<li>Integers</li>
<li>Floats</li>
<li>Atoms</li>
<li>Booleans</li>
<li>Characters</li>
</ul>
<h1><a class="header" href="#primitive-types-1" id="primitive-types-1">Primitive Types</a></h1>
<p>This chapter covers the basic types of data available to LFE, upon which primatives rest LFE libraries and applications.</p>
<ul>
<li>Integers</li>
<li>Floats</li>
<li>Atoms</li>
<li>Booleans</li>
<li>Characters</li>
</ul>
<h1><a class="header" href="#lists" id="lists">Lists</a></h1>
<h1><a class="header" href="#bytes-and-binaries" id="bytes-and-binaries">Bytes and Binaries</a></h1>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<h1><a class="header" href="#property-lists" id="property-lists">Property Lists</a></h1>
<h1><a class="header" href="#maps" id="maps">Maps</a></h1>
<h1><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h1>
<h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<h1><a class="header" href="#dicts" id="dicts">Dicts</a></h1>
<h1><a class="header" href="#records" id="records">Records</a></h1>
<h1><a class="header" href="#generic-sequence-functions" id="generic-sequence-functions">Generic Sequence Functions</a></h1>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<h1><a class="header" href="#closures" id="closures">Closures</a></h1>
<h1><a class="header" href="#evaluation" id="evaluation">Evaluation</a></h1>
<h1><a class="header" href="#flow-of-control" id="flow-of-control">Flow of Control</a></h1>
<h1><a class="header" href="#processes" id="processes">Processes</a></h1>
<h1><a class="header" href="#messages-and-their-passing" id="messages-and-their-passing">Messages and Their Passing</a></h1>
<h1><a class="header" href="#objects-and-flavors" id="objects-and-flavors">Objects and Flavors</a></h1>
<h1><a class="header" href="#io" id="io">I/O</a></h1>
<h1><a class="header" href="#accessing-files" id="accessing-files">Accessing Files</a></h1>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<h1><a class="header" href="#packages" id="packages">Packages</a></h1>
<h1><a class="header" href="#scripting-with-lfe" id="scripting-with-lfe">Scripting with LFE</a></h1>
<h1><a class="header" href="#errors-and-debugging" id="errors-and-debugging">Errors and Debugging</a></h1>
<h1><a class="header" href="#writing-unit-tests" id="writing-unit-tests">Writing Unit Tests</a></h1>
<h1><a class="header" href="#the-common-test-framework" id="the-common-test-framework">The Common Test Framework</a></h1>
<h1><a class="header" href="#the-propr-test-framework" id="the-propr-test-framework">The Propr Test Framework</a></h1>
<h1><a class="header" href="#the-compiler" id="the-compiler">The Compiler</a></h1>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<h1><a class="header" href="#distributed-lfe" id="distributed-lfe">Distributed LFE</a></h1>
<h1><a class="header" href="#ports-and-port-drivers" id="ports-and-port-drivers">Ports and Port Drivers</a></h1>
<h1><a class="header" href="#servers" id="servers">Servers</a></h1>
<h1><a class="header" href="#clients" id="clients">Clients</a></h1>
<h1><a class="header" href="#otp-behaviours" id="otp-behaviours">OTP Behaviours</a></h1>
<h1><a class="header" href="#applications" id="applications">Applications</a></h1>
<h1><a class="header" href="#releases" id="releases">Releases</a></h1>
<h1><a class="header" href="#tables-and-databases" id="tables-and-databases">Tables and Databases</a></h1>
<h1><a class="header" href="#example-otp-project" id="example-otp-project">Example OTP Project</a></h1>
<h1><a class="header" href="#epilogue" id="epilogue">Epilogue</a></h1>
<h1><a class="header" href="#afterword" id="afterword">Afterword</a></h1>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<h1><a class="header" href="#bibliography" id="bibliography">Bibliography</a></h1>
<h1><a class="header" href="#appendices" id="appendices">Appendices</a></h1>
<h1><a class="header" href="#the-origins-of-lisp" id="the-origins-of-lisp">The Origins of Lisp</a></h1>
<h1><a class="header" href="#the-origins-of-erlang" id="the-origins-of-erlang">The Origins of Erlang</a></h1>
<h1><a class="header" href="#an-overview-of-lfe" id="an-overview-of-lfe">An Overview of LFE</a></h1>
<h1><a class="header" href="#versions" id="versions">Versions</a></h1>
<h2><a class="header" href="#current" id="current">Current</a></h2>
<p>The current version of the LFE MACHINE MANUAL is written against LFE 2.0-dev.</p>
<h2><a class="header" href="#previous" id="previous">Previous</a></h2>
<p>After the LFE 2.0 release, you will see a link to content created as part of that effort here. At which point the &quot;Current&quot; version will be incremented.</p>
<h1><a class="header" href="#feedback-and-documantation-bugs" id="feedback-and-documantation-bugs">Feedback and Documantation Bugs</a></h1>
<p>If you would like to provide feedback about this guide, we would welcome the
chance to improve the experience for everyone. Please
<a href="https://github.com/cnbbooks/lfe-manual/issues/new">create a ticket</a> in the
Github issue tracker. Be sure to give a full description so that we can best
help you!</p>
<meta http-equiv="refresh" content="0; URL=http://docs.lfe.io/" />
<meta http-equiv="refresh" content="0; URL=https://github.com/rust-lang/mdbook/" />

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    

                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            

            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];

        // make sure we don't activate google analytics if the developer is
        // inspecting the book locally...
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-38274766-4', 'auto');
            ga('send', 'pageview');
        }
    </script>
    

    

    
    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    
    
    <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>
    
    

</body>

</html>
